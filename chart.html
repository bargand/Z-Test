<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Comprehensive Z-Test Calculator</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f5f5f5;
        margin: 0;
        padding: 20px;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }

      h1 {
        color: #2c3e50;
        text-align: center;
        margin-bottom: 30px;
      }

      h2 {
        color: #3498db;
        margin-top: 25px;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
      }

      select,
      input,
      button {
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
        box-sizing: border-box;
      }

      button {
        background-color: #3498db;
        color: white;
        border: none;
        cursor: pointer;
        font-size: 16px;
        margin-top: 20px;
        transition: background-color 0.3s;
      }

      button:hover {
        background-color: #2980b9;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .hidden {
        display: none;
      }

      #results {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 5px;
        margin-top: 20px;
      }

      .result-item {
        margin-bottom: 10px;
      }

      .significant {
        color: #e74c3c;
        font-weight: bold;
      }

      .not-significant {
        color: #2ecc71;
        font-weight: bold;
      }

      .critical-value {
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 4px;
        margin-top: 10px;
      }

      #confidenceSection {
        margin-top: 20px;
        padding: 15px;
        background-color: #f8f9fa;
        border-radius: 5px;
      }

      #hypothesisSection {
        margin-top: 20px;
      }

      .result-item strong {
        display: inline-block;
        width: 180px;
      }

      #graphContainer {
        margin-top: 30px;
        padding: 20px;
        background-color: #f9f9f9;
        border-radius: 5px;
      }

      #resultsChart {
        width: 100% !important;
        height: 400px !important;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Comprehensive Z-Test Calculator</h1>

      <div class="test-selection">
        <h2>Select Analysis Type</h2>
        <select id="testType">
          <option value="">-- Select Test Type --</option>
          <optgroup label="Hypothesis Tests">
            <option value="oneSample">One-Sample Z-Test</option>
            <option value="twoSample">Two-Sample Z-Test</option>
            <option value="proportionOne">Z-Test for One Proportion</option>
            <option value="proportionTwo">Z-Test for Two Proportions</option>
          </optgroup>
          <optgroup label="Confidence Intervals">
            <option value="ciSingleMean">CI for Single Mean</option>
            <option value="ciTwoMeans">CI for Two Independent Means</option>
            <option value="ciSingleProportion">CI for Single Proportion</option>
            <option value="ciTwoProportions">CI for Two Proportions</option>
          </optgroup>
        </select>
      </div>

      <div id="inputForm" class="hidden">
        <h2>Test Parameters</h2>
        <form id="zTestForm">
          <!-- Dynamic inputs will go here -->
        </form>

        <div id="hypothesisSection" class="hidden">
          <h2>Hypothesis Testing</h2>
          <div>
            <label>Null Hypothesis (H₀):</label>
            <span id="nullHypothesis"></span>
          </div>
          <div>
            <label>Alternative Hypothesis (H₁):</label>
            <span id="altHypothesis"></span>
          </div>
          <div>
            <label>Test Type:</label>
            <select id="tailType">
              <option value="twoTailed">Two-Tailed Test</option>
              <option value="leftTailed">Left-Tailed Test (H₁: <)</option>
              <option value="rightTailed">Right-Tailed Test (H₁: >)</option>
            </select>
          </div>
          <div>
            <label>Significance Level (α):</label>
            <select id="significanceLevel">
              <option value="0.01">0.01 (1%)</option>
              <option value="0.05" selected>0.05 (5%)</option>
              <option value="0.10">0.10 (10%)</option>
            </select>
          </div>
        </div>

        <div id="confidenceSection" class="hidden">
          <h2>Confidence Interval</h2>
          <div>
            <label>Confidence Level:</label>
            <select id="confidenceLevel">
              <!-- Options will be populated by JavaScript -->
            </select>
          </div>
        </div>

        <button id="calculateBtn">Calculate</button>
      </div>

      <div id="results" class="hidden">
        <h2>Analysis Results</h2>
        <div id="resultContent"></div>
        <div id="graphContainer" class="hidden">
          <h2>Visualization</h2>
          <canvas id="resultsChart"></canvas>
        </div>
        <button id="newTestBtn">Perform New Analysis</button>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // DOM Elements
        const testTypeSelect = document.getElementById("testType");
        const inputForm = document.getElementById("inputForm");
        const zTestForm = document.getElementById("zTestForm");
        const resultsDiv = document.getElementById("results");
        const resultContent = document.getElementById("resultContent");
        const calculateBtn = document.getElementById("calculateBtn");
        const newTestBtn = document.getElementById("newTestBtn");
        const nullHypothesis = document.getElementById("nullHypothesis");
        const altHypothesis = document.getElementById("altHypothesis");
        const tailType = document.getElementById("tailType");
        const significanceLevel = document.getElementById("significanceLevel");
        const confidenceLevel = document.getElementById("confidenceLevel");
        let resultsChart = null;

        // Constants
        const TEST_TYPES = {
          ONE_SAMPLE: "oneSample",
          TWO_SAMPLE: "twoSample",
          PROPORTION_ONE: "proportionOne",
          PROPORTION_TWO: "proportionTwo",
          CI_SINGLE_MEAN: "ciSingleMean",
          CI_TWO_MEANS: "ciTwoMeans",
          CI_SINGLE_PROPORTION: "ciSingleProportion",
          CI_TWO_PROPORTIONS: "ciTwoProportions",
        };

        const TAIL_TYPES = {
          TWO_TAILED: "twoTailed",
          LEFT_TAILED: "leftTailed",
          RIGHT_TAILED: "rightTailed",
        };

        // Critical Z-values for common alpha levels (two-tailed)
        const CRITICAL_VALUES = {
          0.01: 2.5758,
          0.05: 1.96,
          0.1: 1.6449,
        };

        // Initialize the application
        function init() {
          setupEventListeners();
          populateConfidenceLevels();
        }

        // Populate confidence level options
        function populateConfidenceLevels() {
          const levels = [80, 85, 90, 95, 99];
          confidenceLevel.innerHTML = levels
            .map((level) => `<option value="${level}">${level}%</option>`)
            .join("");
        }

        // Set up all event listeners
        function setupEventListeners() {
          testTypeSelect.addEventListener("change", handleTestTypeChange);
          tailType.addEventListener("change", updateHypothesisText);
          calculateBtn.addEventListener("click", handleCalculateClick);
          newTestBtn.addEventListener("click", resetCalculator);
        }

        // Handle test type selection change
        function handleTestTypeChange() {
          const selectedTest = testTypeSelect.value;

          if (selectedTest) {
            inputForm.classList.remove("hidden");
            generateInputFields(selectedTest);
            updateHypothesisText();

            // Show/hide appropriate sections
            const isConfidenceInterval = selectedTest.startsWith("ci");
            document
              .getElementById("hypothesisSection")
              .classList.toggle("hidden", isConfidenceInterval);
            document
              .getElementById("confidenceSection")
              .classList.toggle("hidden", !isConfidenceInterval);
          } else {
            inputForm.classList.add("hidden");
          }

          resultsDiv.classList.add("hidden");
        }

        // Generate input fields based on selected test type
        function generateInputFields(testType) {
          zTestForm.innerHTML = "";

          switch (testType) {
            case TEST_TYPES.ONE_SAMPLE:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="sampleMean">Sample Mean (x̄)</label>
                                <input type="number" id="sampleMean" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="popMean">Population Mean (μ)</label>
                                <input type="number" id="popMean" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="popStdDev">Population Standard Deviation (σ)</label>
                                <input type="number" id="popStdDev" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="sampleSize">Sample Size (n)</label>
                                <input type="number" id="sampleSize" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.TWO_SAMPLE:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="sampleMean1">Sample 1 Mean (x̄₁)</label>
                                <input type="number" id="sampleMean1" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="sampleMean2">Sample 2 Mean (x̄₂)</label>
                                <input type="number" id="sampleMean2" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="popStdDev1">Population 1 Standard Deviation (σ₁)</label>
                                <input type="number" id="popStdDev1" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="popStdDev2">Population 2 Standard Deviation (σ₂)</label>
                                <input type="number" id="popStdDev2" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="sampleSize1">Sample 1 Size (n₁)</label>
                                <input type="number" id="sampleSize1" min="2" required>
                            </div>
                            <div class="form-group">
                                <label for="sampleSize2">Sample 2 Size (n₂)</label>
                                <input type="number" id="sampleSize2" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.PROPORTION_ONE:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="sampleProp">Sample Proportion (p̂)</label>
                                <input type="number" id="sampleProp" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="popProp">Population Proportion (p₀)</label>
                                <input type="number" id="popProp" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="propSampleSize">Sample Size (n)</label>
                                <input type="number" id="propSampleSize" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.PROPORTION_TWO:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="sampleProp1">Sample 1 Proportion (p̂₁)</label>
                                <input type="number" id="sampleProp1" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="sampleProp2">Sample 2 Proportion (p̂₂)</label>
                                <input type="number" id="sampleProp2" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="propSampleSize1">Sample 1 Size (n₁)</label>
                                <input type="number" id="propSampleSize1" min="2" required>
                            </div>
                            <div class="form-group">
                                <label for="propSampleSize2">Sample 2 Size (n₂)</label>
                                <input type="number" id="propSampleSize2" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.CI_SINGLE_MEAN:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="ciSampleMean">Sample Mean (x̄)</label>
                                <input type="number" id="ciSampleMean" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPopStdDev">Population Standard Deviation (σ)</label>
                                <input type="number" id="ciPopStdDev" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciSampleSize">Sample Size (n)</label>
                                <input type="number" id="ciSampleSize" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.CI_TWO_MEANS:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="ciSampleMean1">Sample 1 Mean (x̄₁)</label>
                                <input type="number" id="ciSampleMean1" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciSampleMean2">Sample 2 Mean (x̄₂)</label>
                                <input type="number" id="ciSampleMean2" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPopStdDev1">Population 1 Standard Deviation (σ₁)</label>
                                <input type="number" id="ciPopStdDev1" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPopStdDev2">Population 2 Standard Deviation (σ₂)</label>
                                <input type="number" id="ciPopStdDev2" min="0.0001" step="any" required>
                            </div>
                            <div class="form-group">
                                <label for="ciSampleSize1">Sample 1 Size (n₁)</label>
                                <input type="number" id="ciSampleSize1" min="2" required>
                            </div>
                            <div class="form-group">
                                <label for="ciSampleSize2">Sample 2 Size (n₂)</label>
                                <input type="number" id="ciSampleSize2" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.CI_SINGLE_PROPORTION:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="ciSampleProp">Sample Proportion (p̂)</label>
                                <input type="number" id="ciSampleProp" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPropSampleSize">Sample Size (n)</label>
                                <input type="number" id="ciPropSampleSize" min="2" required>
                            </div>
                        `;
              break;

            case TEST_TYPES.CI_TWO_PROPORTIONS:
              zTestForm.innerHTML = `
                            <div class="form-group">
                                <label for="ciSampleProp1">Sample 1 Proportion (p̂₁)</label>
                                <input type="number" id="ciSampleProp1" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="ciSampleProp2">Sample 2 Proportion (p̂₂)</label>
                                <input type="number" id="ciSampleProp2" min="0" max="1" step="0.0001" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPropSampleSize1">Sample 1 Size (n₁)</label>
                                <input type="number" id="ciPropSampleSize1" min="2" required>
                            </div>
                            <div class="form-group">
                                <label for="ciPropSampleSize2">Sample 2 Size (n₂)</label>
                                <input type="number" id="ciPropSampleSize2" min="2" required>
                            </div>
                        `;
              break;
          }
        }

        // Update hypothesis text based on selected test and tail type
        function updateHypothesisText() {
          const testType = testTypeSelect.value;
          const tail = tailType.value;

          if (!testType || testType.startsWith("ci")) return;

          let nullText = "";
          let altText = "";

          switch (testType) {
            case TEST_TYPES.ONE_SAMPLE:
              nullText = "μ = μ₀ (population mean equals hypothesized value)";
              switch (tail) {
                case TAIL_TYPES.LEFT_TAILED:
                  altText =
                    "μ < μ₀ (population mean is less than hypothesized value)";
                  break;
                case TAIL_TYPES.RIGHT_TAILED:
                  altText =
                    "μ > μ₀ (population mean is greater than hypothesized value)";
                  break;
                default:
                  altText =
                    "μ ≠ μ₀ (population mean differs from hypothesized value)";
              }
              break;

            case TEST_TYPES.TWO_SAMPLE:
              nullText = "μ₁ = μ₂ (population means are equal)";
              switch (tail) {
                case TAIL_TYPES.LEFT_TAILED:
                  altText =
                    "μ₁ < μ₂ (population 1 mean is less than population 2 mean)";
                  break;
                case TAIL_TYPES.RIGHT_TAILED:
                  altText =
                    "μ₁ > μ₂ (population 1 mean is greater than population 2 mean)";
                  break;
                default:
                  altText = "μ₁ ≠ μ₂ (population means are not equal)";
              }
              break;

            case TEST_TYPES.PROPORTION_ONE:
              nullText =
                "p = p₀ (population proportion equals hypothesized value)";
              switch (tail) {
                case TAIL_TYPES.LEFT_TAILED:
                  altText =
                    "p < p₀ (population proportion is less than hypothesized value)";
                  break;
                case TAIL_TYPES.RIGHT_TAILED:
                  altText =
                    "p > p₀ (population proportion is greater than hypothesized value)";
                  break;
                default:
                  altText =
                    "p ≠ p₀ (population proportion differs from hypothesized value)";
              }
              break;

            case TEST_TYPES.PROPORTION_TWO:
              nullText = "p₁ = p₂ (population proportions are equal)";
              switch (tail) {
                case TAIL_TYPES.LEFT_TAILED:
                  altText =
                    "p₁ < p₂ (population 1 proportion is less than population 2 proportion)";
                  break;
                case TAIL_TYPES.RIGHT_TAILED:
                  altText =
                    "p₁ > p₂ (population 1 proportion is greater than population 2 proportion)";
                  break;
                default:
                  altText = "p₁ ≠ p₂ (population proportions are not equal)";
              }
              break;
          }

          nullHypothesis.textContent = nullText;
          altHypothesis.textContent = altText;
        }

        // Handle calculate button click
        function handleCalculateClick() {
          try {
            const testType = testTypeSelect.value;

            if (!testType) {
              throw new Error("Please select a test type");
            }

            if (testType.startsWith("ci")) {
              calculateConfidenceInterval(testType);
            } else {
              calculateHypothesisTest(testType);
            }
          } catch (error) {
            alert(`Error: ${error.message}`);
            console.error(error);
          }
        }

        // Calculate hypothesis test
        function calculateHypothesisTest(testType) {
          const alpha = parseFloat(significanceLevel.value);
          const tail = tailType.value;

          // Validate alpha
          if (isNaN(alpha)) {
            throw new Error("Significance level must be a number");
          }

          let zScore, pValue, pooledProp;

          switch (testType) {
            case TEST_TYPES.ONE_SAMPLE:
              zScore = calculateOneSampleZScore();
              break;

            case TEST_TYPES.TWO_SAMPLE:
              zScore = calculateTwoSampleZScore();
              break;

            case TEST_TYPES.PROPORTION_ONE:
              zScore = calculateProportionOneZScore();
              break;

            case TEST_TYPES.PROPORTION_TWO:
              const result = calculateProportionTwoZScore();
              zScore = result.zScore;
              pooledProp = result.pooledProp;
              break;
          }

          // Calculate p-value based on tail type
          pValue = calculatePValue(zScore, tail);

          // Determine if result is significant
          const isSignificant = pValue < alpha;

          // Get critical value (using standard table values)
          const criticalValue = getCriticalValue(alpha, tail);

          // Display results
          displayHypothesisResults(
            testType,
            zScore,
            pValue,
            alpha,
            isSignificant,
            criticalValue,
            tail,
            pooledProp
          );

          // Show results section
          resultsDiv.classList.remove("hidden");
        }

        // Calculate confidence interval
        function calculateConfidenceInterval(testType) {
          const confidence = parseInt(confidenceLevel.value);
          const alpha = (100 - confidence) / 100;

          let result;

          switch (testType) {
            case TEST_TYPES.CI_SINGLE_MEAN:
              result = calculateSingleMeanCI(alpha);
              break;

            case TEST_TYPES.CI_TWO_MEANS:
              result = calculateTwoMeansCI(alpha);
              break;

            case TEST_TYPES.CI_SINGLE_PROPORTION:
              result = calculateSingleProportionCI(alpha);
              break;

            case TEST_TYPES.CI_TWO_PROPORTIONS:
              result = calculateTwoProportionsCI(alpha);
              break;
          }

          // Display results
          displayCIResults(testType, confidence, result);

          // Show results section
          resultsDiv.classList.remove("hidden");
        }

        // Calculate one-sample Z-score
        function calculateOneSampleZScore() {
          const sampleMean = parseFloat(
            document.getElementById("sampleMean").value
          );
          const popMean = parseFloat(document.getElementById("popMean").value);
          const popStdDev = parseFloat(
            document.getElementById("popStdDev").value
          );
          const sampleSize = parseInt(
            document.getElementById("sampleSize").value
          );

          // Validate inputs
          if (isNaN(sampleMean))
            throw new Error("Sample mean must be a number");
          if (isNaN(popMean))
            throw new Error("Population mean must be a number");
          if (isNaN(popStdDev) || popStdDev <= 0)
            throw new Error(
              "Population standard deviation must be a positive number"
            );
          if (isNaN(sampleSize))
            throw new Error("Sample size must be a number");
          if (sampleSize < 2) throw new Error("Sample size must be at least 2");

          return (sampleMean - popMean) / (popStdDev / Math.sqrt(sampleSize));
        }

        // Calculate two-sample Z-score
        function calculateTwoSampleZScore() {
          const sampleMean1 = parseFloat(
            document.getElementById("sampleMean1").value
          );
          const sampleMean2 = parseFloat(
            document.getElementById("sampleMean2").value
          );
          const popStdDev1 = parseFloat(
            document.getElementById("popStdDev1").value
          );
          const popStdDev2 = parseFloat(
            document.getElementById("popStdDev2").value
          );
          const sampleSize1 = parseInt(
            document.getElementById("sampleSize1").value
          );
          const sampleSize2 = parseInt(
            document.getElementById("sampleSize2").value
          );

          // Validate inputs
          if (isNaN(sampleMean1))
            throw new Error("Sample 1 mean must be a number");
          if (isNaN(sampleMean2))
            throw new Error("Sample 2 mean must be a number");
          if (isNaN(popStdDev1) || popStdDev1 <= 0)
            throw new Error(
              "Population 1 standard deviation must be a positive number"
            );
          if (isNaN(popStdDev2) || popStdDev2 <= 0)
            throw new Error(
              "Population 2 standard deviation must be a positive number"
            );
          if (isNaN(sampleSize1))
            throw new Error("Sample 1 size must be a number");
          if (isNaN(sampleSize2))
            throw new Error("Sample 2 size must be a number");
          if (sampleSize1 < 2)
            throw new Error("Sample 1 size must be at least 2");
          if (sampleSize2 < 2)
            throw new Error("Sample 2 size must be at least 2");

          const stdError = Math.sqrt(
            Math.pow(popStdDev1, 2) / sampleSize1 +
              Math.pow(popStdDev2, 2) / sampleSize2
          );

          if (stdError === 0) throw new Error("Standard error cannot be zero");

          return (sampleMean1 - sampleMean2) / stdError;
        }

        // Calculate one-proportion Z-score
        function calculateProportionOneZScore() {
          const sampleProp = parseFloat(
            document.getElementById("sampleProp").value
          );
          const popProp = parseFloat(document.getElementById("popProp").value);
          const sampleSize = parseInt(
            document.getElementById("propSampleSize").value
          );

          // Validate inputs
          if (isNaN(sampleProp) || sampleProp < 0 || sampleProp > 1) {
            throw new Error("Sample proportion must be between 0 and 1");
          }
          if (isNaN(popProp) || popProp < 0 || popProp > 1) {
            throw new Error("Population proportion must be between 0 and 1");
          }
          if (isNaN(sampleSize))
            throw new Error("Sample size must be a number");
          if (sampleSize < 2) throw new Error("Sample size must be at least 2");

          // Check for edge cases
          if (popProp === 0 || popProp === 1) {
            throw new Error(
              "Population proportion cannot be exactly 0 or 1 for this test"
            );
          }

          const stdError = Math.sqrt((popProp * (1 - popProp)) / sampleSize);

          if (stdError === 0) throw new Error("Standard error cannot be zero");

          return (sampleProp - popProp) / stdError;
        }

        // Calculate two-proportion Z-score (returns both zScore and pooledProp)
        function calculateProportionTwoZScore() {
          const sampleProp1 = parseFloat(
            document.getElementById("sampleProp1").value
          );
          const sampleProp2 = parseFloat(
            document.getElementById("sampleProp2").value
          );
          const sampleSize1 = parseInt(
            document.getElementById("propSampleSize1").value
          );
          const sampleSize2 = parseInt(
            document.getElementById("propSampleSize2").value
          );

          // Validate inputs
          if (isNaN(sampleProp1) || sampleProp1 < 0 || sampleProp1 > 1) {
            throw new Error("Sample 1 proportion must be between 0 and 1");
          }
          if (isNaN(sampleProp2) || sampleProp2 < 0 || sampleProp2 > 1) {
            throw new Error("Sample 2 proportion must be between 0 and 1");
          }
          if (isNaN(sampleSize1))
            throw new Error("Sample 1 size must be a number");
          if (isNaN(sampleSize2))
            throw new Error("Sample 2 size must be a number");
          if (sampleSize1 < 2)
            throw new Error("Sample 1 size must be at least 2");
          if (sampleSize2 < 2)
            throw new Error("Sample 2 size must be at least 2");

          const pooledProp =
            (sampleProp1 * sampleSize1 + sampleProp2 * sampleSize2) /
            (sampleSize1 + sampleSize2);

          const stdError = Math.sqrt(
            pooledProp * (1 - pooledProp) * (1 / sampleSize1 + 1 / sampleSize2)
          );

          if (stdError === 0) throw new Error("Standard error cannot be zero");

          return {
            zScore: (sampleProp1 - sampleProp2) / stdError,
            pooledProp: pooledProp,
          };
        }

        // Calculate single mean confidence interval
        function calculateSingleMeanCI(alpha) {
          const sampleMean = parseFloat(
            document.getElementById("ciSampleMean").value
          );
          const popStdDev = parseFloat(
            document.getElementById("ciPopStdDev").value
          );
          const sampleSize = parseInt(
            document.getElementById("ciSampleSize").value
          );

          // Validate inputs
          if (isNaN(sampleMean))
            throw new Error("Sample mean must be a number");
          if (isNaN(popStdDev) || popStdDev <= 0)
            throw new Error(
              "Population standard deviation must be a positive number"
            );
          if (isNaN(sampleSize))
            throw new Error("Sample size must be a number");
          if (sampleSize < 2) throw new Error("Sample size must be at least 2");

          const zCritical = getCriticalValue(alpha / 2, TAIL_TYPES.TWO_TAILED);
          const marginOfError = zCritical * (popStdDev / Math.sqrt(sampleSize));

          return {
            lower: sampleMean - marginOfError,
            upper: sampleMean + marginOfError,
            marginOfError: marginOfError,
            zCritical: zCritical,
          };
        }

        // Calculate two means confidence interval
        function calculateTwoMeansCI(alpha) {
          const sampleMean1 = parseFloat(
            document.getElementById("ciSampleMean1").value
          );
          const sampleMean2 = parseFloat(
            document.getElementById("ciSampleMean2").value
          );
          const popStdDev1 = parseFloat(
            document.getElementById("ciPopStdDev1").value
          );
          const popStdDev2 = parseFloat(
            document.getElementById("ciPopStdDev2").value
          );
          const sampleSize1 = parseInt(
            document.getElementById("ciSampleSize1").value
          );
          const sampleSize2 = parseInt(
            document.getElementById("ciSampleSize2").value
          );

          // Validate inputs
          if (isNaN(sampleMean1))
            throw new Error("Sample 1 mean must be a number");
          if (isNaN(sampleMean2))
            throw new Error("Sample 2 mean must be a number");
          if (isNaN(popStdDev1) || popStdDev1 <= 0)
            throw new Error(
              "Population 1 standard deviation must be a positive number"
            );
          if (isNaN(popStdDev2) || popStdDev2 <= 0)
            throw new Error(
              "Population 2 standard deviation must be a positive number"
            );
          if (isNaN(sampleSize1))
            throw new Error("Sample 1 size must be a number");
          if (isNaN(sampleSize2))
            throw new Error("Sample 2 size must be a number");
          if (sampleSize1 < 2)
            throw new Error("Sample 1 size must be at least 2");
          if (sampleSize2 < 2)
            throw new Error("Sample 2 size must be at least 2");

          const zCritical = getCriticalValue(alpha / 2, TAIL_TYPES.TWO_TAILED);
          const stdError = Math.sqrt(
            Math.pow(popStdDev1, 2) / sampleSize1 +
              Math.pow(popStdDev2, 2) / sampleSize2
          );

          const difference = sampleMean1 - sampleMean2;
          const marginOfError = zCritical * stdError;

          return {
            lower: difference - marginOfError,
            upper: difference + marginOfError,
            marginOfError: marginOfError,
            zCritical: zCritical,
          };
        }

        // Calculate single proportion confidence interval
        function calculateSingleProportionCI(alpha) {
          const sampleProp = parseFloat(
            document.getElementById("ciSampleProp").value
          );
          const sampleSize = parseInt(
            document.getElementById("ciPropSampleSize").value
          );

          // Validate inputs
          if (isNaN(sampleProp) || sampleProp < 0 || sampleProp > 1) {
            throw new Error("Sample proportion must be between 0 and 1");
          }
          if (isNaN(sampleSize))
            throw new Error("Sample size must be a number");
          if (sampleSize < 2) throw new Error("Sample size must be at least 2");

          const zCritical = getCriticalValue(alpha / 2, TAIL_TYPES.TWO_TAILED);
          const stdError = Math.sqrt(
            (sampleProp * (1 - sampleProp)) / sampleSize
          );

          const marginOfError = zCritical * stdError;

          return {
            lower: Math.max(0, sampleProp - marginOfError),
            upper: Math.min(1, sampleProp + marginOfError),
            marginOfError: marginOfError,
            zCritical: zCritical,
          };
        }

        // Calculate two proportions confidence interval
        function calculateTwoProportionsCI(alpha) {
          const sampleProp1 = parseFloat(
            document.getElementById("ciSampleProp1").value
          );
          const sampleProp2 = parseFloat(
            document.getElementById("ciSampleProp2").value
          );
          const sampleSize1 = parseInt(
            document.getElementById("ciPropSampleSize1").value
          );
          const sampleSize2 = parseInt(
            document.getElementById("ciPropSampleSize2").value
          );

          // Validate inputs
          if (isNaN(sampleProp1) || sampleProp1 < 0 || sampleProp1 > 1) {
            throw new Error("Sample 1 proportion must be between 0 and 1");
          }
          if (isNaN(sampleProp2) || sampleProp2 < 0 || sampleProp2 > 1) {
            throw new Error("Sample 2 proportion must be between 0 and 1");
          }
          if (isNaN(sampleSize1))
            throw new Error("Sample 1 size must be a number");
          if (isNaN(sampleSize2))
            throw new Error("Sample 2 size must be a number");
          if (sampleSize1 < 2)
            throw new Error("Sample 1 size must be at least 2");
          if (sampleSize2 < 2)
            throw new Error("Sample 2 size must be at least 2");

          const zCritical = getCriticalValue(alpha / 2, TAIL_TYPES.TWO_TAILED);
          const stdError = Math.sqrt(
            (sampleProp1 * (1 - sampleProp1)) / sampleSize1 +
              (sampleProp2 * (1 - sampleProp2)) / sampleSize2
          );

          const difference = sampleProp1 - sampleProp2;
          const marginOfError = zCritical * stdError;

          return {
            lower: Math.max(-1, difference - marginOfError),
            upper: Math.min(1, difference + marginOfError),
            marginOfError: marginOfError,
            zCritical: zCritical,
          };
        }

        // Calculate p-value based on Z-score and tail type
        function calculatePValue(zScore, tail) {
          // Standard normal cumulative distribution function
          const cdf = (z) => {
            if (z < -8.0) return 0.0;
            if (z > 8.0) return 1.0;

            let sum = 0.0;
            let term = z;
            let i = 3;

            while (sum + term !== sum) {
              sum += term;
              term *= (z * z) / i;
              i += 2;
            }

            return 0.5 + sum * Math.exp(-0.5 * z * z - 0.9189385332046727);
          };

          switch (tail) {
            case TAIL_TYPES.LEFT_TAILED:
              return cdf(zScore);

            case TAIL_TYPES.RIGHT_TAILED:
              return 1 - cdf(zScore);

            case TAIL_TYPES.TWO_TAILED:
              return 2 * (1 - cdf(Math.abs(zScore)));

            default:
              throw new Error("Invalid tail type specified");
          }
        }

        // Get critical value based on alpha and tail type (using standard table values)
        function getCriticalValue(alpha, tail) {
          // For two-tailed tests, we already have the positive critical value
          if (tail === TAIL_TYPES.TWO_TAILED) {
            return CRITICAL_VALUES[alpha * 2] || 1.96; // Default to 1.96 for 0.05 alpha
          }
          // For one-tailed tests, use the same table but adjust alpha
          return CRITICAL_VALUES[alpha] || 1.6449; // Default to 1.6449 for 0.05 alpha
        }

        // Create chart visualization
        function createChart(testType, zScore, criticalValue, tail, alpha) {
          const ctx = document.getElementById("resultsChart").getContext("2d");
          const graphContainer = document.getElementById("graphContainer");
          graphContainer.classList.remove("hidden");

          // Destroy previous chart if it exists
          if (resultsChart) {
            resultsChart.destroy();
          }

          const isTwoTailed = tail === TAIL_TYPES.TWO_TAILED;
          const leftCritical = isTwoTailed
            ? -criticalValue
            : tail === TAIL_TYPES.LEFT_TAILED
            ? criticalValue
            : -Infinity;
          const rightCritical = isTwoTailed
            ? criticalValue
            : tail === TAIL_TYPES.RIGHT_TAILED
            ? criticalValue
            : Infinity;

          // Create data points for the normal curve
          const labels = [];
          const normalData = [];
          const criticalData = [];
          const acceptedData = [];

          for (let i = -30; i <= 30; i++) {
            const z = i / 5;
            labels.push(z.toFixed(1));
            const y = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
            normalData.push(y);

            if (z <= leftCritical || z >= rightCritical) {
              criticalData.push(y);
              acceptedData.push(null);
            } else {
              criticalData.push(null);
              acceptedData.push(y);
            }
          }

          // Determine chart type based on test
          let title;
          if (testType.startsWith("ci")) {
            title = "Confidence Interval Visualization";
          } else {
            title = "Hypothesis Test Visualization";
          }

          // Create the chart
          resultsChart = new Chart(ctx, {
            type: "line",
            data: {
              labels: labels,
              datasets: [
                {
                  label: "Standard Normal Distribution",
                  data: normalData,
                  borderColor: "rgb(75, 192, 192)",
                  backgroundColor: "rgba(75, 192, 192, 0.1)",
                  borderWidth: 2,
                  fill: false,
                  pointRadius: 0,
                },
                {
                  label: "Critical Region",
                  data: criticalData,
                  borderColor: "rgb(255, 99, 132)",
                  backgroundColor: "rgba(255, 99, 132, 0.5)",
                  borderWidth: 1,
                  fill: "+1",
                  pointRadius: 0,
                },
                {
                  label: "Accepted Region",
                  data: acceptedData,
                  borderColor: "rgb(54, 162, 235)",
                  backgroundColor: "rgba(54, 162, 235, 0.3)",
                  borderWidth: 1,
                  fill: false,
                  pointRadius: 0,
                },
              ],
            },
            options: {
              responsive: true,
              plugins: {
                title: {
                  display: true,
                  text: title,
                  font: {
                    size: 16,
                  },
                },
                legend: {
                  position: "top",
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                },
              },
              scales: {
                x: {
                  title: {
                    display: true,
                    text: "Z-Score",
                  },
                },
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: "Probability Density",
                  },
                },
              },
            },
          });

          // Add Z-score marker for hypothesis tests
          if (!testType.startsWith("ci")) {
            resultsChart.data.datasets.push({
              label: "Calculated Z-Score",
              data: labels.map((z) => {
                const numZ = parseFloat(z);
                return Math.abs(numZ - zScore) < 0.1
                  ? Math.exp(-0.5 * numZ * numZ) / Math.sqrt(2 * Math.PI)
                  : null;
              }),
              borderColor: "rgb(153, 102, 255)",
              backgroundColor: "rgb(153, 102, 255)",
              borderWidth: 2,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false,
            });
            resultsChart.update();
          }
        }

        // Display hypothesis test results
        function displayHypothesisResults(
          testType,
          zScore,
          pValue,
          alpha,
          isSignificant,
          criticalValue,
          tail,
          pooledProp
        ) {
          const testName = getTestName(testType);
          const comparison = getComparisonText(criticalValue, tail);
          const tailDescription = getTailDescription(tail);

          // Format pValue to show exact number when possible
          let formattedPValue;
          if (pValue < 0.0001) {
            formattedPValue = pValue.toExponential(4);
          } else {
            formattedPValue = pValue.toFixed(6).replace(/\.?0+$/, "");
          }

          let resultHTML = `
            <div class="result-item">
              <strong>Test Performed:</strong> ${testName}
            </div>
            <div class="result-item">
              <strong>Z-Score:</strong> ${zScore.toFixed(4)}
            </div>`;

          // Show pooled proportion for two-proportion test
          if (
            testType === TEST_TYPES.PROPORTION_TWO &&
            pooledProp !== undefined
          ) {
            resultHTML += `
              <div class="result-item">
                <strong>Pooled Proportion:</strong> ${pooledProp.toFixed(4)}
              </div>`;
          }

          resultHTML += `
            <div class="result-item">
              <strong>p-value:</strong> ${formattedPValue}
            </div>
            <div class="result-item">
              <strong>Significance Level (α):</strong> ${alpha}
            </div>
            <div class="result-item">
              <strong>Critical Value${
                tail === TAIL_TYPES.TWO_TAILED ? "s" : ""
              }:</strong> 
              ${
                tail === TAIL_TYPES.TWO_TAILED
                  ? `±${criticalValue.toFixed(4)}`
                  : criticalValue.toFixed(4)
              }
            </div>
            <div class="result-item ${
              isSignificant ? "significant" : "not-significant"
            }">
              <strong>Conclusion:</strong> ${
                isSignificant
                  ? "Reject the null hypothesis (H₀). The result is statistically significant."
                  : "Fail to reject the null hypothesis (H₀). The result is not statistically significant."
              }
            </div>
            <div class="critical-value">
              <strong>Interpretation:</strong> 
              <p>A ${tailDescription} test was performed at α = ${alpha} level of significance.</p>
              <p>The calculated p-value (${formattedPValue}) is ${
            pValue < alpha ? "less" : "greater"
          } than α.</p>
              <p>Z-score of ${zScore.toFixed(4)} ${
            isSignificant
              ? "falls in the critical region"
              : "does not fall in the critical region"
          }.</p>
            </div>`;

          resultContent.innerHTML = resultHTML;

          createChart(testType, zScore, criticalValue, tail, alpha);
        }

        // Display confidence interval results
        function displayCIResults(testType, confidence, result) {
          const testName = getTestName(testType);

          resultContent.innerHTML = `
            <div class="result-item">
              <strong>Analysis Performed:</strong> ${testName}
            </div>
            <div class="result-item">
              <strong>Confidence Level:</strong> ${confidence}%
            </div>
            <div class="result-item">
              <strong>Critical Z-Value:</strong> ±${result.zCritical.toFixed(4)}
            </div>
            <div class="result-item">
              <strong>Margin of Error:</strong> ${result.marginOfError.toFixed(
                4
              )}
            </div>
            <div class="result-item significant">
              <strong>Confidence Interval:</strong> 
              (${result.lower.toFixed(4)}, ${result.upper.toFixed(4)})
            </div>
            <div class="critical-value">
              <strong>Interpretation:</strong> 
              <p>We are ${confidence}% confident that the true population parameter falls between 
              ${result.lower.toFixed(4)} and ${result.upper.toFixed(4)}.</p>
            </div>
          `;

          createChart(
            testType,
            null,
            result.zCritical,
            TAIL_TYPES.TWO_TAILED,
            (100 - confidence) / 100
          );
        }

        // Helper function to get test name
        function getTestName(testType) {
          switch (testType) {
            case TEST_TYPES.ONE_SAMPLE:
              return "One-Sample Z-Test";
            case TEST_TYPES.TWO_SAMPLE:
              return "Two-Sample Z-Test";
            case TEST_TYPES.PROPORTION_ONE:
              return "Z-Test for One Proportion";
            case TEST_TYPES.PROPORTION_TWO:
              return "Z-Test for Two Proportions";
            case TEST_TYPES.CI_SINGLE_MEAN:
              return "Confidence Interval for Single Mean";
            case TEST_TYPES.CI_TWO_MEANS:
              return "Confidence Interval for Difference of Two Means";
            case TEST_TYPES.CI_SINGLE_PROPORTION:
              return "Confidence Interval for Single Proportion";
            case TEST_TYPES.CI_TWO_PROPORTIONS:
              return "Confidence Interval for Difference of Two Proportions";
            default:
              return "Statistical Analysis";
          }
        }

        // Helper function to get comparison text
        function getComparisonText(criticalValue, tail) {
          switch (tail) {
            case TAIL_TYPES.LEFT_TAILED:
              return `Z < ${criticalValue.toFixed(4)}`;
            case TAIL_TYPES.RIGHT_TAILED:
              return `Z > ${criticalValue.toFixed(4)}`;
            case TAIL_TYPES.TWO_TAILED:
              return `|Z| > ${criticalValue.toFixed(4)}`;
            default:
              return "";
          }
        }

        // Helper function to get tail description
        function getTailDescription(tail) {
          switch (tail) {
            case TAIL_TYPES.LEFT_TAILED:
              return "left-tailed";
            case TAIL_TYPES.RIGHT_TAILED:
              return "right-tailed";
            case TAIL_TYPES.TWO_TAILED:
              return "two-tailed";
            default:
              return "";
          }
        }

        // Reset the calculator
        function resetCalculator() {
          if (resultsChart) {
            resultsChart.destroy();
            resultsChart = null;
          }
          document.getElementById("graphContainer").classList.add("hidden");
          resultsDiv.classList.add("hidden");
          inputForm.classList.add("hidden");
          testTypeSelect.value = "";
          zTestForm.reset();
        }

        // Initialize the application
        init();
      });
    </script>
  </body>
</html>
